package immutableArrayBoard;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.function.Function;

import boardFeatures.DownRightDiagonal;
import boardFeatures.File;
import boardFeatures.Rank;
import boardFeatures.Square;
import boardFeatures.UpRightDiagonal;
import gamePlaying.Color;
import moves.Move;
import pieces.Piece;
import representation.Board;
import representation.CastlingRights;
import representation.MoveGenerator;
import support.BadArgumentException;

/**
 * Calculates the moves for a given position. This is a mutable object, and 
 * @author matthewslesinski
 *
 */
public class ImmutableArrayMoveGenerator extends MoveGenerator<ImmutableArrayBoard> {
	private static final int NUMBER_OF_CASTLING_RIGHTS = CastlingRights.values().length;

	/**
	 * Acting like a list and backed by an array, this keeps a list of squares that you can add to, up to the maxSize,
	 * but can't remove from. Therefore, this is able to keep track of where the squares are placed, so it can quickly
	 * get neighbors as well as the index of a particular square.
	 * @author matthewslesinski
	 *
	 */
	private static class FixedSizeList {
		private final Square[] squares;
		private final int[] indices = new int[Square.values().length];
		int size = 0;
		
		private FixedSizeList(int maxSize) {
			this.squares = new Square[maxSize];
		}
		
		/**
		 * Adds a square to this list
		 * @param square The square to add
		 */
		private void add(Square square) {
			if (size >= squares.length) {
				throw new BadArgumentException(square, FixedSizeList.class, "Can't add too many squares to this list");
			}
			squares[size] = square;
			indices[square.getIndex()] = size++;
		}
		
		private boolean contains(Square square) {
			return squares[indices[square.getIndex()]] == square;
		}
		
		/**
		 * Gets the square in this list that is a certain number of other squares removed from the current one
		 * @param square The current square
		 * @param diff The number of squares removed the other one is
		 * @return The square a certain number of other squares removed
		 */
		private Square getNeighbor(Square square, int diff) {
			if (!contains(square)) {
				throw new BadArgumentException(square, FixedSizeList.class, "This square is not in this list");
			}
			int index = indices[square.getIndex()] + diff;
			if (index < 0 || index >= size) {
				return null;
			}
			return squares[index];
		}
		
		/**
		 * Gets the next square in this list
		 * @param square The current square
		 * @return The next one
		 */
		private Square getNext(Square square) {
			return getNeighbor(square, 1);
		}
		
		/**
		 * Gets the previous square in this list
		 * @param square The current square
		 * @return The previous one
		 */
		private Square getPrevious(Square square) {
			return getNeighbor(square, -1);
		}
		
	}
	private class PreProcessing {
		
		private Color toMove;
		private boolean[] castlingRights = new boolean[CastlingRights.values().length];
		private Piece[] board = new Piece[Square.values().length];
		@SuppressWarnings("unchecked")
		private List<Square>[] piecesAndSquares = new List[Piece.values().length];
		private FixedSizeList[] fileSquares = new FixedSizeList[File.values().length];
		private FixedSizeList[] rankSquares = new FixedSizeList[Rank.values().length];
		private FixedSizeList[] upRightSquares = new FixedSizeList[UpRightDiagonal.values().length];
		private FixedSizeList[] downRightSquares = new FixedSizeList[DownRightDiagonal.values().length];
		
		private PreProcessing(ImmutableArrayBoard board) {
			toMove = board.whoseMove();
			for (int i = 0; i < NUMBER_OF_CASTLING_RIGHTS; i++) {
				castlingRights[i] = board.canCastle(CastlingRights.values()[i]);
			}
			
			initializeLists(piecesAndSquares, index -> new ArrayList<Square>(10));
			initializeLists(fileSquares, index -> new FixedSizeList(8));
			initializeLists(rankSquares, index -> new FixedSizeList(8));
			initializeLists(upRightSquares, index -> new FixedSizeList(UpRightDiagonal.getByIndex(index).getLength()));
			initializeLists(downRightSquares, index -> new FixedSizeList(DownRightDiagonal.getByIndex(index).getLength()));

			
			
			preProcessBoard(board);
			
		}
		
		/**
		 * Initializes all list in the appropriate array, using the index of the array that each list will be in
		 * @param arr The array to put the lists in
		 * @param constructor How to initialize each list
		 */
		private <T> void initializeLists(T[] arr, Function<Integer, T> constructor) {
			int length = arr.length;
			for (int i = 0; i < length; i++) {
				arr[i] = constructor.apply(i);
			}
		}
		
		private void preProcessBoard(ImmutableArrayBoard board) {
			for (Square square : Square.values()) {
				
			}
		}
		
		
		
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	@Override
	public Set<Move> calculateMoves(ImmutableArrayBoard board) {
		clear();
		// TODO
		return null;
	}
	
	/**
	 * Resets the MoveGenerator to its original state
	 */
	// TODO finish this
	private void clear() {
		
	}

}
