package dataStructures;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NavigableSet;
import java.util.Spliterator;
import java.util.function.IntFunction;

import convenienceDataStructures.UnmodifiableWrappedList;
import support.BadArgumentException;
import support.UtilityFunctions;

public class ListBackedByMaps<E extends Enum<E>> implements Isomorphism<E, E>, FixedOrderingSet<E>, UnmodifiableWrappedList<E> {

	private final Map<E, E> forwards;
	private final Map<E, E> backwards;
	private final List<E> elements;

	@SuppressWarnings("unchecked")
	public ListBackedByMaps(Collection<E> collection) {
		if (collection.isEmpty()) {
			throw new BadArgumentException(collection, collection.getClass(), "Expected a non-empty collection");
		}
		this.elements = new ArrayList<>(collection);
		Class<E> type = (Class<E>) elements.get(0).getClass();
		this.forwards = new EnumMap<>(type);
		this.backwards = new EnumMap<>(type);
		E previous = null;
		for (E element : elements) {
			if (previous != null) {
				put(previous, element);
			}
			previous = element;
		}
	}
	
	/**
	 * Gets the next element in this list
	 * @param element The element to retrieve the one next to it for
	 * @return The next element
	 */
	public E getNext(E element) {
		return element == null ? elements.get(0) : getByElementOnLeft(element);
	}
	
	/**
	 * Gets the previous element in this list
	 * @param element The element to retrieve the one previous to it for
	 * @return The previous element
	 */
	public E getPrevious(E element) {
		return element == null ? elements.get(size() - 1) : getByElementOnRight(element);
	}

	@Override
	public Map<E, E> getLeftwardMap() {
		return forwards;
	}


	@Override
	public Map<E, E> getRightwardMap() {
		return backwards;
	}



	@Override
	public Comparator<? super E> comparator() {
		return new Comparator<E>() {
			@Override
			public int compare(E o1, E o2) {
				return o1.ordinal() - o2.ordinal();
			}
		};
	}


	@Override
	public NavigableSet<E> descendingSet() {
		return new ListBackedByMaps<E>(UtilityFunctions.reverseList(elements));
	}


	@Override
	public NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
		int fromIndex = indexOf(fromElement);
		int toIndex = indexOf(toElement);
		if (!fromInclusive) {
			fromIndex += 1;
		}
		if (!toInclusive) {
			toIndex += 1;
		}
		return new ListBackedByMaps<E>(elements.subList(fromIndex, toIndex));
	}


	@Override
	public E retrieveOffsetFromElement(E element, int offset) {
		int index = indexOf(element) + offset;
		return index >= 0 && index < size() ? get(indexOf(element) + offset) : null;
	}


	@Override
	public IntFunction<E> getIndexFunction() {
		return this::get;
	}


	@Override
	public void clear() {
		UnmodifiableWrappedList.super.clear();
	}


	@Override
	public int size() {
		return UnmodifiableWrappedList.super.size();
	}


	@Override
	public boolean isEmpty() {
		return UnmodifiableWrappedList.super.isEmpty();
	}



	@Override
	public boolean containsAll(Collection<?> c) {
		return FixedOrderingSet.super.containsAll(c);
	}


	@Override
	public boolean retainAll(Collection<?> c) {
		return UnmodifiableWrappedList.super.retainAll(c);
	}


	@Override
	public boolean remove(Object o) {
		return UnmodifiableWrappedList.super.remove(o);
	}


	@Override
	public boolean removeAll(Collection<?> c) {
		return UnmodifiableWrappedList.super.removeAll(c);
	}


	@Override
	public Iterator<E> iterator() {
		return UnmodifiableWrappedList.super.iterator();
	}
	
	@Override
	public List<E> getWrappedList() {
		return elements;
	}


	@Override
	public boolean contains(Object o) {
		return containsKeyOnLeft(o) || containsKeyOnRight(o);
	}


	@Override
	public Spliterator<E> spliterator() {
		return UnmodifiableWrappedList.super.spliterator();
	}


	@Override
	public Object[] toArray() {
		return UnmodifiableWrappedList.super.toArray();
	}


	@Override
	public <T> T[] toArray(T[] a) {
		return UnmodifiableWrappedList.super.toArray(a);
	}

}
