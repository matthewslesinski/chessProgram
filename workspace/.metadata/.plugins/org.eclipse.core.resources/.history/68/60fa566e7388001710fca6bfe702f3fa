package moves;

import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import boardFeatures.Square;
import gamePlaying.Color;
import lines.Direction;
import lines.File;
import pieces.Piece;
import representation.Board;
import representation.CastlingRights;
import support.BadArgumentException;

public class StraightforwardPreProcessing<B extends Board> implements ProcessedBoard<B> {

	/** The color to move */
	private final Color toMove;
	
	/** The opposite color of the one to move */
	private final Color oppositeColor;
	
	/** Array of the booleans for each castling right, for if it's allowed without accounting for specifics of the position */
	private final Map<CastlingRights, Boolean> castlingRights = new EnumMap<>(CastlingRights.class);
	
	/** The file to capture onto with en passant, or null if not allowed */
	private final File enPassantFile;
	
	/** Stores which {@code Piece} is at which {@code Square} */
	private final Map<Square, Piece> pieces = new EnumMap<>(Square.class);
	
	/**
	 * Stores the pieces on the board in another intuitive arrangement. Each index of the array
	 * will be the list with the squares that the piece with that ordinal (minus 1 because Piece.NONE is not included) is on
	 */
	private final Map<Piece, List<Square>> piecesToSquares = new EnumMap<>(Piece.class);
	
	/** The square with the king of the player to move */
	private final Square kingSquare;
	
	/** For each {@code Square} around the king, this holds the {@code Square}s of the pieces attacking it */
	private final Map<Square, Set<Square>> attackedSquaresAroundKing = new EnumMap<>(Square.class);
	
	/** For each {@code Square} with a {@code Piece} that is pinned, this holds the {@code Direction} from that {@code Square} to the attacking {@code Piece}'s {@code Square} */
	private final Map<Square, Direction> pins = new EnumMap<>(Square.class);
	
	/** This holds the {@code Square}s the king can safely move to. It is lazily instantiated */
	private Set<Square> safeKingDestinations = null;
	
	
	
	
	@Override
	public Color whoseMove() {
		return toMove;
	}

	@Override
	public boolean canCastle(CastlingRights right) {
		return castlingRights.getOrDefault(right, false);
	}

	@Override
	public File getEnPassantFile() {
		return enPassantFile;
	}

	@Override
	public List<Square> getListOfSquaresForPiece(Piece piece) {
		if (piece == Piece.NONE) {
			throw new BadArgumentException(piece, Piece.class, "An absent piece cannot be associated with a square");
		}
		return piecesToSquares.get(piece);
	}

	@Override
	public Piece getPieceAtSquare(Square square) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void calculateKingSafety() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Set<Square> whoIsAttackingTheKing() {
		return attackedSquaresAroundKing.getOrDefault(kingSquare, Collections.emptySet());
	}

	@Override
	public Set<Square> getSafeKingDestinations() {
		if (safeKingDestinations == null) {
			safeKingDestinations = kingSquare.getKingMoves(toMove).stream()
				.filter(square -> attackedSquaresAroundKing.get(square) == null)
				.collect(Collectors.toCollection(() -> EnumSet.noneOf(Square.class)));
		}
		return safeKingDestinations;
	}

	@Override
	public boolean isMovementBlocked(Square start, Square end) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public Direction isPiecePinned(Square square) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public boolean isEnPassantPinned(File movingPawnFile) {
		// TODO Auto-generated method stub
		return false;
	}

}
