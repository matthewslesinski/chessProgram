package moves;

import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;

import boardFeatures.Direction;
import boardFeatures.DownRightDiagonal;
import boardFeatures.File;
import boardFeatures.Line;
import boardFeatures.LineType;
import boardFeatures.Rank;
import boardFeatures.Square;
import boardFeatures.UpRightDiagonal;
import dataStructures.EnumSequence;
import dataStructures.FixedOrderingSet;
import dataStructures.KingMoveSet;
import gamePlaying.Color;
import pieces.Piece;
import pieces.PieceType;
import representation.Board;
import representation.CastlingRights;
import support.BadArgumentException;
import support.UtilityFunctions;

/**
 * Used to preprocess a board before calculating the moves, so that calculating them is easier. The main benefits of this class
 * are that it can provide the basic info about the board, such as which piece is on a square, the player to move, castling abilities,
 * and en passant abilities, but it can also list all the squares a piece of particular type and color is on, as well as efficiently
 * retrieving information about which king move is safe, whether the king is in check, and if pieces are pinned
 * @author matthewslesinski
 *
 */
public class BasicPreProcessing<B extends Board> implements ProcessedBoard<B> {
	
	/** The color to move */
	private final Color toMove;
	
	/** The opposite color of the one to move */
	private final Color oppositeColor;
		
	/** Array of the booleans for each castling right, for if it's allowed without accounting for specifics of the position */
	private final Map<CastlingRights, Boolean> castlingRights = new EnumMap<>(CastlingRights.class);
	
	/** The file to capture onto with en passant, or null if not allowed */
	private final File enPassantFile;
	
	/** Stores the pieces on the board in the most intuitive arrangement. Each index of the array will be the piece at the square with that index as its index */
	private final Piece[] pieces = new Piece[Square.values().length];
	
	/**
	 * Stores the pieces on the board in another intuitive arrangement. Each index of the array
	 * will be the list with the squares that the piece with that ordinal (minus 1 because Piece.NONE is not included) is on
	 */
	@SuppressWarnings("unchecked")
	private final List<Square>[] piecesToSquares = new List[Piece.values().length - 1];
	
	/** The four following arrays of lists contain the squares with pieces on them for each of the instances of a line type */
	@SuppressWarnings("rawtypes")
	private final FixedOrderingSet[][] preProcessedLines = {
		new FixedOrderingSet[File.values().length],	
		new FixedOrderingSet[Rank.values().length],
		new FixedOrderingSet[UpRightDiagonal.values().length],														
		new FixedOrderingSet[DownRightDiagonal.values().length]
	};
	
	private final Square kingSquare;
	
	private final Map<Square, Set<Square>> safeSquaresAroundKing = new EnumMap<>(Square.class);
	
	
	/**
	 * Initiates the preprocessing
	 * @param board The board to decompress
	 */
	public BasicPreProcessing(B board) {
		toMove = board.whoseMove();
		oppositeColor = toMove.getOtherColor();
		for (CastlingRights right : CastlingRights.values()) {
			castlingRights.put(right, board.canCastle(right));
		}
		enPassantFile = board.enPassantCaptureFile();
		
		initializeLists(piecesToSquares, index -> new ArrayList<Square>(10));
		parseBoard(board);
		initializeLines();
		kingSquare = getPieceSquares(Piece.getByColorAndType(toMove, PieceType.KING)).get(0);
		
	}
	
	@SuppressWarnings("unchecked")
	private FixedOrderingSet<Square>[] retrievePreProcessingForType(LineType type) {
		return UtilityFunctions.getValueFromArray(preProcessedLines, type);
	}
	
	/**
	 * Parses a board into a state where it is easy to see which piece is on which square and also which squares have particular pieces
	 * @param board The board to parse
	 */
	private void parseBoard(B board) {
		for (Square square : Square.values()) {
			Piece piece = board.getPieceAtSquare(square);
			if (piece != Piece.NONE ) {
				pieces[square.getIndex()] = piece;
				piecesToSquares[piece.ordinal() - 1].add(square);
			}
		}
	}
	
	/**
	 * Initializes all list in the appropriate array, using the index of the array that each list will be in
	 * @param arr The array to put the lists in
	 * @param constructor How to initialize each list
	 */
	private <T> void initializeLists(T[] arr, Function<Integer, T> constructor) {
		int length = arr.length;
		for (int i = 0; i < length; i++) {
			arr[i] = constructor.apply(i);
		}
	}
	
	/**
	 * Retrieves the list of squares that a particular piece is on
	 * @param piece The piece to get squares for
	 * @return The list of squares containing that piece
	 */
	private List<Square> getPieceSquares(Piece piece) {
		return piecesToSquares[piece.ordinal() - 1];
	}
	
	/**
	 * Initializes the preprocessing for a line and adds all the pieces in that line to the preprocessing list
	 * @param line The line
	 * @param arr The array to put the preprocessing in for storage
	 */
	private void preProcessLine(Line line, FixedOrderingSet<Square>[] arr) {
		FixedOrderingSet<Square> list = new EnumSequence<Square>(Square.class, line.getLength(),
										square -> square.getNeighbor(line.getForwardDirection().getOppositeDirection()), line::containsSquare);
		line.getContainedSquares().forEach(square -> {
			Piece piece = square.getValueOfSquareInArray(pieces);
			if (piece != Piece.NONE) {
				list.add(square);
			}
		});
		arr[line.getIndex()] = list;
	}
	
	/**
	 * Performs the preprocessing
	 */
	private void initializeLines() {
		for (PieceType lineMover: PieceType.getLineMovers()) {
			Piece relevantPiece = Piece.getByColorAndType(toMove.getOtherColor(), lineMover);
			List<Square> relevantSquares = getPieceSquares(relevantPiece);
			relevantSquares.forEach(square -> {
				for (LineType type : LineType.values()) {
					preProcessLine(type.getLineBySquare(square), retrievePreProcessingForType(type));
				}		
			});
		}
	}
	
	@Override
	public Color whoseMove() {
		return toMove;
	}
	
	@Override
	public boolean canCastle(CastlingRights right) {
		return castlingRights.getOrDefault(right, false);
	}
	
	@Override
	public File getEnPassantFile() {
		return enPassantFile;
	}
	
	@Override
	public List<Square> getListOfSquaresForPiece(Piece piece) {
		if (piece == Piece.NONE) {
			throw new BadArgumentException(piece, Piece.class, "An absent piece cannot be associated with a square");
		}
		return piecesToSquares[piece.ordinal() - 1];
	}
	
	@Override
	public Piece getPieceAtSquare(Square square) {
		return square.getValueOfSquareInArray(pieces);
	}
	
	/**
	 * Retrieves the pre processed line containing a square and covering a line of a particular type
	 * @param containedSquare The square contained in the line
	 * @param lineType The type of line
	 * @return The pre processing for that line
	 */
	private FixedOrderingSet<Square> getListOfImportantSquares(Square containedSquare, LineType lineType) {
		int indexOfPreProcessing = lineType.getLineBySquare(containedSquare).getIndex();
		return retrievePreProcessingForType(lineType)[indexOfPreProcessing];
	}
	
	/**
	 * Retrieves the piece that is n pieces away from the current square in a direction
	 * @param square The current square
	 * @param dir The direction to look
	 * @param n How many pieces away
	 * @return The square containing the piece or null
	 */
	public Square getNPiecesAway(Square square, Direction dir, int n) {
		if (n < 0) {
			throw new BadArgumentException(n, Integer.class, "Steps away can't be negative");
		}
		int sign = dir.getMovement().getIncrement();
		int numberOfSteps = n * sign;
		LineType lineType = dir.getContainingLineType();
		FixedOrderingSet<Square> listOfSquares = getListOfImportantSquares(square, lineType);
		
		return listOfSquares.retrieveOffsetFromElement(square, numberOfSteps);
	}

	/**
	 * Gets the square with a piece on it that is next along the direction
	 * @param square The current square
	 * @param dir The direction to travel
	 * @return The {@code Square}, or null if none
	 */
	public Square getNextSquareWithPiece(Square square, Direction dir) {
		return getNPiecesAway(square, dir, 1);
	}
	
	private void calculateKnightAttacks(KingMoveSet kingMoves) {
		Piece opposingKnight = Piece.getByColorAndType(oppositeColor, PieceType.KNIGHT);
		for (Square knightSquare : piecesToSquares[opposingKnight.ordinal()]) {
			for (Square attackedSquare : kingMoves.getRelevantSquares(knightSquare, this::getPieceAtSquare)) {
				Set<Square> attackers = safeSquaresAroundKing.getOrDefault(attackedSquare, EnumSet.noneOf(Square.class));
				attackers.add(knightSquare);
				safeSquaresAroundKing.putIfAbsent(attackedSquare, attackers);
			}
		}
	}
	
	private boolean isThreat(Square target, Square potentialAttacker) {
		Piece attacker = getPieceAtSquare(potentialAttacker);
		return attacker.getColor() == oppositeColor && attacker.threatensInDirection(potentialAttacker.getDirectionToSquare(target));
	}
	
	private void calculateSquareAttackers(Square potentiallyAttackedSquare, KingMoveSet kingMoves, Set<Square> squaresToIgnore) {
		for (LineType lineType : LineType.values()) {
			FixedOrderingSet<Square> listOfSquares = getListOfImportantSquares(potentiallyAttackedSquare, lineType);
			for (Square neighbor : listOfSquares.getNeighbors(potentiallyAttackedSquare, squaresToIgnore)) {
				
			}
		}
	}
	
	private void calculateKingAttackers() {
		
	}
	
	@Override
	public void calculateKingSafety() {
		// Set up
		KingMoveSet kingMoves = kingSquare.getKingMoves(toMove);
		Piece king = pieces[kingSquare.getIndex()];
		pieces[kingSquare.getIndex()] = Piece.NONE;
		Set<Square> squareToIgnore = Collections.singleton(kingSquare);
		
		// Calculate
		calculateKnightAttacks(kingMoves);
		for (Square square : kingMoves) {
			if (safeSquaresAroundKing.get(square) != null) {
				calculateSquareAttackers(square, kingMoves, squareToIgnore);
			}
		}
		calculateKingAttackers();
		// reset the board
		pieces[kingSquare.getIndex()] = king;
	}
	
	@Override
	public List<Square> whoIsAttackingTheKing() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<Square> getSafeKingDestinations() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Direction isPiecePinned(Square square) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public boolean isEnPassantPinned(File movingPawnFile) {
		// TODO Auto-generated method stub
		return false;
	}

}
