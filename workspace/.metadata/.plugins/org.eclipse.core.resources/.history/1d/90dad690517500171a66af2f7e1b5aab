package dataStructures;

import java.util.Collection;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;

import boardFeatures.Line;
import boardFeatures.LineType;
import boardFeatures.Square;
import pieces.Piece;
import support.UtilityFunctions;

public class SquareSet implements Cluster<Square> {
	
	private final Set<Square> squares;
	private final Map<Piece, Map<Square, BiFunction<Predicate<Square>, Square, Square>>> potentialThreats = new EnumMap<>(Piece.class);
	private final Square center;
	private int radius;
	
	public SquareSet(Collection<Square> elementsWithoutCenter, Square center) {
		Collection<Square> elements = UtilityFunctions.concat(elementsWithoutCenter, Collections.singleton(center));
		this.squares = EnumSet.copyOf(elements);
		for (Piece piece : Piece.realPieces()) {
			Map<Square, BiFunction<Predicate<Square>, Square, Square>> innerMap = new EnumMap<>(Square.class);
			potentialThreats.put(piece, innerMap);
			for (Square remoteSquare : Square.values()) {
				Function<Square, Square> relevantLocalSquares = new LinkedList<>();
				for (Square localSquare : remoteSquare.pieceMoves(piece, this.squares::contains)) {
					relevantLocalSquares.add(localSquare);
				}
			}
			
		}
		this.center = center;
	}
	
	public Iterator<Square> getRelevantSquares(Square perspective, Piece occupant, Predicate<Square> shouldTraverse) {
		
	}

	
	
	@Override
	public Square getCenter() {
		return center;
	}

	@Override
	public Set<Square> getWrappedSet() {
		return this.squares;
	}
	
	@Override
	public Set<Square> getAllOnLine(Line line) {
		return lineIndexedSquares.get(line.getType()).getOrDefault(line, Collections.emptySet());
	}
	
	@Override
	public int getRadius() {
		return radius;
	}
}
