package moves;


import boardFeatures.Square;
import pieces.PieceType;
import support.BadArgumentException;

public class BasicMove implements Move {

	private static final Boolean[] BOOLEAN_OPTIONS = {false, true};
	
	private final PieceType movingPiece;
	private final boolean isCapture;
	private final PieceType capturedPiece;
	private final Square start;
	private final Square end;
	private final boolean isCastle;
	private final boolean isPromotion;
	private final PieceType promotionPiece;
	private final boolean isEnPassant;
	
	
	public BasicMove(int compressedMove) {
		movingPiece = getObject(PieceType.values(), MoveBitStringSection.MOVING_PIECE, compressedMove);
		isCapture = getObject(BOOLEAN_OPTIONS, MoveBitStringSection.IS_CAPTURE, compressedMove);
		capturedPiece = isCapture ? getObject(PieceType.values(), MoveBitStringSection.CAPTURE_PIECE, compressedMove) : null;
		start = getObject(Square.values(), MoveBitStringSection.START_SQUARE, compressedMove);
		end = getObject(Square.values(), MoveBitStringSection.END_SQUARE, compressedMove);
		isCastle = getObject(BOOLEAN_OPTIONS, MoveBitStringSection.IS_CASTLE, compressedMove);
		isPromotion = getObject(BOOLEAN_OPTIONS, MoveBitStringSection.IS_PROMOTION, compressedMove);
		promotionPiece = isPromotion ? getObject(PieceType.getPromotionPieces(), MoveBitStringSection.PROMOTION_TYPE, compressedMove) : null;
		isEnPassant = getObject(BOOLEAN_OPTIONS, MoveBitStringSection.IS_EN_PASSANT, compressedMove);	
	}
	
	private BasicMove(MoveType type, PieceType movingPiece, Square start, Square end, PieceType extraArg) {
		this.start = start;
		this.end = end;
		this.movingPiece = movingPiece;
		PieceType captureArg = null;
		PieceType promotionArg = null;
		boolean isCaptureArg = false;
		boolean isCastleArg = false;
		boolean isPromotionArg = false;
		boolean isEnPassantArg = false;
		switch (type) {
		case CAPTURE:
			isCaptureArg = true;
			captureArg = extraArg;
			break;
		case CASTLE:
			isCastleArg = true;
			break;
		case PROMOTION:
			isPromotionArg = true;
			promotionArg = extraArg;
			break;
		case EN_PASSANT:
			isEnPassantArg = true;
			break;
		default:
			break;
		}
		this.isCapture = isCaptureArg;
		this.isCastle = isCastleArg;
		this.isPromotion = isPromotionArg;
		this.isEnPassant = isEnPassantArg;
		this.promotionPiece = promotionArg;
		this.capturedPiece = captureArg;
	}
	
	/**
	 * Retrieves an index from an array, where the index is what the {@code section} of {@code compressedMove} holds
	 * @param options The array to retrieve from
	 * @param section The bit section of the int that has the index
	 * @param compressedMove The compressed representation of this move.
	 * @return
	 */
	private <T> T getObject(T[] options, MoveBitStringSection section, int compressedMove) {
		return options[section.getValue(compressedMove)];
	}
	
	@Override
	public PieceType getMovingPiece() {
		return movingPiece;
	}
	
	@Override
	public boolean isCapture() {
		return isCapture;
	}
	
	@Override
	public PieceType getCapturedPiece() {
		return capturedPiece;
	}

	@Override
	public boolean isPromotion() {
		return isPromotion;
	}
	
	@Override
	public PieceType getPromotionPiece() {
		return promotionPiece;
	}

	@Override
	public boolean isCastle() {
		return isCastle;
	}

	@Override
	public boolean isEnPassant() {
		return isEnPassant;
	}

	@Override
	public Square getStartSquare() {
		return start;
	}

	@Override
	public Square getEndSquare() {
		return end;
	}

	@Override
	public int compress() {
		// TODO Auto-generated method stub
		return 0;
	}
	
	public static class Builder {
		
		private Square start = null;
		private Square end = null;
		private PieceType movingPiece = null;
		private MoveType type = null;
		private PieceType capturedPiece = null;
		private PieceType promotionPiece = null;
		
		public Builder(MoveType type, PieceType movingPiece, Square start, Square end) {
			this.type = type;
			this.movingPiece = movingPiece;
			this.start = start;
			this.end = end;
			switch (type) {
			case CASTLE:
				argCheck(movingPiece, PieceType.class, PieceType.KING);
				break;
			case EN_PASSANT:
				capturedPiece = PieceType.PAWN;
				//roll on down to promotion
			case PROMOTION:
				argCheck(movingPiece, PieceType.class, PieceType.PAWN);
				break;
			default:
				break;
			}
			
		}
		
		public Builder withCapture(PieceType capturedPiece) {
			argCheck(this.capturedPiece, PieceType.class, null);
			if (this.type == MoveType.CAPTURE || this.type == MoveType.PROMOTION) {
				this.capturedPiece = capturedPiece;
			} else {
				throw new BadArgumentException(this.type, MoveType.class, "This move type cannot involve capture a " + capturedPiece.toString());
			}
			return this;
		}
		
		public Builder withPromotion(PieceType promotionPiece) {
			argCheck(this.promotionPiece, PieceType.class, null);
			
			if (this.type == MoveType.PROMOTION) {
				this.promotionPiece = promotionPiece;
			} else {
				throw new BadArgumentException(this.type, MoveType.class, "This move cannot involve promoting to a " + promotionPiece.toString());
			}
			return this;
		}
		
		public BasicMove build() {
			PieceType extraArg = null;
			switch (type) {
			case PROMOTION:
				if (this.promotionPiece == null) {
					throw new BadArgumentException(this, Builder.class, "A promotion must involve promoting a to piece");
				}
				extraArg = this.promotionPiece;
				break;
			case CAPTURE:
				if (this.capturedPiece == null) {
					throw new BadArgumentException(this, Builder.class, "A capture must involve capturing a piece");
				}
				extraArg = this.capturedPiece;
			default:
				break;
			}
			return new BasicMove(type, movingPiece, start, end, extraArg);
		}
		
		
		/**
		 * Makes sure that a variable doesn't get initiated twice
		 * @param toCheck The object that gets initialized
		 * @param objectClass The object's class
		 */
		private static void argCheck(Object toCheck, Class<?> objectClass, Object expected) {
			if (toCheck != expected) {
				throw new BadArgumentException(toCheck, objectClass, expected == null ? "null expected" : "The value was already initialized to " + expected.toString());
			}
		}
	}

}
