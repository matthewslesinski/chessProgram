package dataStructures;

import java.util.Collection;
import java.util.EnumMap;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;

import boardFeatures.Direction;
import boardFeatures.Square;
import pieces.Piece;

public class OutwardLinePortions implements Cluster<Square> {

	private final Square center;
	private final ListBackedByMaps<Square> elements;
	private final Map<Direction, Square> closestInDirections;
	private final ListBackedByMaps<Direction> directions;
	
	public OutwardLinePortions(Square center, Collection<Square> importantSquares) {
		this.center = center;
		this.elements = new ListBackedByMaps<>(importantSquares);
		this.closestInDirections = new EnumMap<>(Direction.class);
		importantSquares.forEach(square -> closestInDirections.merge(center.getDirectionToSquare(square), square, this::getCloser));
		this.directions = new ListBackedByMaps<>(closestInDirections.keySet());
		
	}
	
	/**
	 * Determines which of the two squares is closer to the center, and returns that one
	 * @param that one square to consider
	 * @param other the other one to consider
	 * @return The one that's closer to the center
	 */
	private Square getCloser(Square that, Square other) {
		if (Square.getManhattanDistance(center, that) > Square.getManhattanDistance(center, other)) {
			return other;
		}
		return that;
	}
	
	@Override
	public Set<Square> getWrappedSet() {
		return elements;
	}

	@Override
	public Square getCenter() {
		return center;
	}
	
	/**
	 * If there's a piece on the current square, this returns the first square in the next direction to cycle over, otherwise the next one to
	 * consider in general
	 * @param curr The current square
	 * @param occupants A function that describes which pieces are at which squares
	 * @return The next square
	 */
	public Square getNext(Square curr, Function<Square, Piece> occupants) {
		Piece occupant = occupants.apply(curr);
		if (occupant == Piece.NONE || occupant == null) {
			return elements.getNext(curr);
		}
		Direction dirToCurr = center.getDirectionToSquare(curr);
		Direction nextDirection = directions.getNext(dirToCurr);
		return nextDirection == null ? null : closestInDirections.get(nextDirection);
	}
}
