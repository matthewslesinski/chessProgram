package dataStructures;

import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.NavigableSet;
import java.util.SortedSet;
import java.util.function.Function;
import java.util.function.Predicate;

import javax.swing.event.ListSelectionEvent;

import support.BadArgumentException;

/**
 * This keeps a list of enums that you can add to, up to the maxSize, but can't remove from.
 * Also, any insertions must involve an enum value that is the highest yet inserted, according to whatever
 * ordering is imposed by the {@code getPreviousPossibleValue} function passed to the constructor.
 * With these guarantees, this is able to keep track of where the elements are placed, so it can quickly
 * get neighbors as well as the index of a particular element.
 * This is guaranteed by maintaining the following paradigm. There is an array (elements) that just holds,
 * one after another, the elements so far added to this sequence. Furthermore, there is a map (indicesMap) that
 * keeps track of which index in the array contains the added elements.
 * Furthermore, at some point, we may want to find the neighbors of elements that could be in this sequence but
 * weren't added. This capability is maintained by having the map also point each element that could've been added
 * and occurs before the 
 * @author matthewslesinski
 * 
 */
public class EnumSequence<E extends Enum<E>> implements FixedOrderingSet<E> {

	private static final String REMOVAL_MESSAGE = "Removal is not allowed for this sequence";
	
	private final Class<E> type;
	private final Map<E, Integer> indicesMap;
	private final E[] elements;
	private int size = 0;
	private final Function<E, E> getPreviousPossibleValue;
	private final Predicate<E> isPossibleValue;

	/**
	 * Returns an instance of this sequence. Each element that is added to this instance must be greater in ordinal than the
	 * previous.
	 * @param type The type of enum stored in this sequence
	 * @param maxSize The largest number of enums that could be stored in this sequence
	 * @param getPreviousPossibleValue A relational function to return the previous instance of this enum that could have been
	 * added to this sequence, so that an unbroken line from start to finish can essentially be created
	 * @param isPossibleValue A function to determine if the given element could possibly belong in this sequence
	 */
	@SuppressWarnings("unchecked")
	public EnumSequence(Class<E> type, int maxSize, Function<E, E> getPreviousPossibleValue, Predicate<E> isPossibleValue) {
		this.indicesMap = new EnumMap<E, Integer>(type);
		this.elements = (E[]) Array.newInstance(type, maxSize);
		this.getPreviousPossibleValue = getPreviousPossibleValue;
		this.type = type;
		this.isPossibleValue = isPossibleValue;
	}
	
	private int retrieveArrayIndex(E element) {
		if (!isPossibleValue.test(element)) {
			throw new BadArgumentException(element, element.getClass(), "This element does not fit within this sequence");
		}
		return indicesMap.getOrDefault(element, size);
	}
	
	@Override
	public boolean add(E e) {
		// If there's not enough space for this element, something went wrong
		if (size >= elements.length) {
			throw new BadArgumentException(e, e.getClass(), "Can't add too many elements to this sequence");
		}
		if (!isPossibleValue.test(e)) {
			throw new BadArgumentException(e, e.getClass(), "This element does not belong in this sequence");
		}
		
		// For each possible element that could've been put in this sequence between the current one, inclusive, and the last one inserted, exclusive,
		// make sure that its value in indicesMap points to the same spot in elements as this one.
		E intermediateElement = e;
		E previousInsertion = size == 0 ? null : elements[size - 1];
		while (intermediateElement != previousInsertion) {
			indicesMap.put(intermediateElement, size);
			// If the getPreviousPossibleValue function is null, assume the previous value is the one last inserted
			intermediateElement = getPreviousPossibleValue == null ? previousInsertion :
									getPreviousPossibleValue.apply(intermediateElement);
		}
		
		// put the current element in its spot in the elements array
		elements[size++] = e;

		return true;
	}
	
	@Override
	public boolean contains(Object o) {
		try {
			return indicesMap.containsKey(o) && elements[indicesMap.get(o)] == o;
		} catch (ClassCastException e) {
			throw new BadArgumentException(o, o.getClass(), "Expected argument of type: " + type.getName());
		}
	}
	
	@Override
	public E retrieveOffsetFromElement(E element, int offset) {
		// If there's nothing in this sequence, or if the provided element does not fit in the ordering of this
		// sequence, then return null
		if (size == 0) {
			return null;
		}
		// If the offset is 0, trivially return this element (which may mean an element is returned that is not
		// actually in the sequence
		if (offset == 0) {
			return element;
		}
		
		int indexToGet;
		// This will tell what index in the elements array contains the provided element, or if the provided element
		// is not in the array, then what index contains the first element after the provided element
		int currentIndex = retrieveArrayIndex(element);
		// If we're seeking an element in the sequence after the provided element, act like we're looking at
		// the provided element or the first in the sequence before it
		if (!contains(element) && offset > 0) {
			currentIndex -= 1;
		}
		
		// Which index in the elements array contains the desired element
		indexToGet = currentIndex + offset;
		// If we go out of bounds, return null
		if (indexToGet < 0 || indexToGet >= size) {
			return null;
		}
		return elements[indexToGet];
	}
	
	@Override
	public Comparator<? super E> comparator() {
		return (E arg1, E arg2) -> {
			return retrieveArrayIndex(arg1) - retrieveArrayIndex(arg2);
		};
		
	}

	@Override
	public E first() {
		return elements[0];
	}

	@Override
	public E last() {
		return isEmpty() ? null : elements[size - 1];
	}

	@Override
	public int size() {
		return size;
	}

	@Override
	public boolean isEmpty() {
		return size == 0;
	}

	

	@Override
	public Object[] toArray() {
		return Arrays.copyOfRange(elements, 0, size);
	}

	@SuppressWarnings("unchecked")
	@Override
	public <T> T[] toArray(T[] a) {
		return (T[]) Arrays.copyOfRange(elements, 0, size, a.getClass());
	}

	

	@Override
	public boolean remove(Object o) {
		throw new BadArgumentException(o, o.getClass(), REMOVAL_MESSAGE);
	}

	@Override
	public boolean containsAll(Collection<?> c) {
		boolean toReturn = true;
		for (Object e : c) {
			toReturn &= contains(e);
		}
		return toReturn;
	}

	@Override
	public boolean addAll(Collection<? extends E> c) {
		boolean toReturn = true;
		for (E e : c) {
			toReturn &= add(e);
		}
		return toReturn;
	}

	@Override
	public boolean retainAll(Collection<?> c) {
		throw new BadArgumentException(c, c.getClass(), REMOVAL_MESSAGE);

	}

	@Override
	public boolean removeAll(Collection<?> c) {
		throw new BadArgumentException(c, c.getClass(), REMOVAL_MESSAGE);
	}

	@Override
	public void clear() {
		throw new BadArgumentException(this, this.getClass(), REMOVAL_MESSAGE);
	}

	@Override
	public E lower(E e) {
		return retrieveOffsetFromElement(e, -1);
	}

	@Override
	public E floor(E e) {
		return contains(e) ? e : lower(e);
	}

	@Override
	public E ceiling(E e) {
		return contains(e) ? e : higher(e);
	}

	@Override
	public E higher(E e) {
		return retrieveOffsetFromElement(e, 1);
	}

	@Override
	public E pollFirst() {
		throw new BadArgumentException(this, this.getClass(), REMOVAL_MESSAGE);

	}

	@Override
	public E pollLast() {
		throw new BadArgumentException(this, this.getClass(), REMOVAL_MESSAGE);

	}

	@Override
	public Iterator<E> iterator() {
		return new Iterator<E>() {
			private int currentIndex = 0;
			
			@Override
			public boolean hasNext() {
				return currentIndex < size;
			}

			@Override
			public E next() {
				return elements[currentIndex++];
			}
		};
	}

	@Override
	public NavigableSet<E> descendingSet() {
		final Map<E, E> predecessorMapping = new EnumMap<>(type);
		for (E enumVal : type.getEnumConstants()) {
			if (!isPossibleValue.test(enumVal)) {
				continue;
			}
			E previousVal = getPreviousPossibleValue.apply(enumVal);
			if (previousVal != null) {
				predecessorMapping.put(previousVal, enumVal);
			}
		}
		return new EnumSequence<E>(type, elements.length, element -> predecessorMapping.get(element), isPossibleValue);
	}

	@Override
	public Iterator<E> descendingIterator() {
		return new Iterator<E>() {
			private int currentIndex = size;
			@Override
			public boolean hasNext() {
				return currentIndex > 0;
			}

			@Override
			public E next() {
				return elements[--currentIndex];
			}
		};
	}

	@Override
	public NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
		NavigableSet<E> toReturn = new EnumSequence<>(type, elements.length, getPreviousPossibleValue, isPossibleValue);
		boolean adding = false;
		for (E element : this) {
			if (element == toElement) {
				adding = false;
				if (toInclusive) {
					toReturn.add(element);
				}
			}
			if (adding) {
				toReturn.add(element);
			}
			if (element == fromElement) {
				adding = true;
				if (fromInclusive) {
					toReturn.add(element);
				}
			}
		}
		return toReturn;
	}

	@Override
	public NavigableSet<E> headSet(E toElement, boolean inclusive) {
		return subSet(elements[0], true, toElement, inclusive);
	}

	@Override
	public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {
		return subSet(fromElement, inclusive, size == 0 ? null : elements[size - 1], true);
	}

	@Override
	public SortedSet<E> subSet(E fromElement, E toElement) {
		return subSet(fromElement, true, toElement, false);
	}

	@Override
	public SortedSet<E> headSet(E toElement) {
		return headSet(toElement, false);
	}

	@Override
	public SortedSet<E> tailSet(E fromElement) {
		return tailSet(fromElement, true);
	}

}
