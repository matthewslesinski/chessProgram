package dataStructures;

import java.util.Collection;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.Iterator;
import java.util.Map;
import java.util.NavigableSet;
import java.util.SortedSet;
import java.util.function.Function;

import boardFeatures.Square;
import support.BadArgumentException;

public class EnumSequence<E extends Enum<E>> implements FixedOrderingSet<E> {

	private final Class<E> type;
	private final Map<E, Integer> indicesMap;
	private final int[] elementOrdinals;
	private int size = 0;
	private final Function<E, E> getPreviousPossibleValue;
	
	/**
	 * Returns an instance of this sequence. Each element that is added to this instance must be greater in ordinal than the
	 * previous.
	 * @param type The type of enum stored in this sequence
	 * @param maxSize The largest number of enums that could be stored in this sequence
	 * @param getPreviousPossibleValue A relational function to return the previous instance of this enum that could have been
	 * added to this sequence, so that an unbroken line from start to finish can essentially be created
	 */
	public EnumSequence(Class<E> type, int maxSize, Function<E, E> getPreviousPossibleValue) {
		this.indicesMap = new EnumMap<E, Integer>(type);
		this.elementOrdinals = new int[maxSize];
		this.getPreviousPossibleValue = getPreviousPossibleValue;
		this.type = type;
	}
	
	private int extractOrdinal(E e) {
		return e == null ? -1 : e.ordinal();
	}
	
	@Override
	public boolean add(E e) {
		// If there's not enough space for this element, something went wrong
		if (size >= elementOrdinals.length) {
			throw new BadArgumentException(e, FixedSizeList.class, "Can't add too many elements to this sequence");
		}
		
		// For each possible element that could've been put in this sequence between the current one, inclusive, and the last one inserted, exclusive,
		// make sure that its value in indicesMap points to the same spot in elementOrdinals as this one.
		E intermediateElement = e;
		int previousOrdinal = size == 0 ? -1 : elementOrdinals[size - 1];
		while (extractOrdinal(intermediateElement) != previousOrdinal) {
			indicesMap.put(intermediateElement, size);
			intermediateElement = getPreviousPossibleValue.apply(intermediateElement);
		}
		
		// put the current element's ordinal in its spot in the elementOrdinals array
		elementOrdinals[size++] = e.ordinal();

		return true;
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public boolean contains(Object o) {
		try {
			E element = (E) o;
			return indicesMap.containsKey(element) && elementOrdinals[indicesMap.get(element)] == element.ordinal();
		} catch (ClassCastException e) {
			throw new BadArgumentException(o, o.getClass(), "Expected argument of type: " + type.getName());
		}
	}
	
	@Override
	public Square retrieveOffsetFromElement(Square square, int diff) {
		// TODO Auto-generated method stub
		return null;
	}
	
	@Override
	public Comparator<? super E> comparator() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public E first() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public E last() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public int size() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public boolean isEmpty() {
		// TODO Auto-generated method stub
		return false;
	}

	

	@Override
	public Object[] toArray() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <T> T[] toArray(T[] a) {
		// TODO Auto-generated method stub
		return null;
	}

	

	@Override
	public boolean remove(Object o) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean containsAll(Collection<?> c) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean addAll(Collection<? extends E> c) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean retainAll(Collection<?> c) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean removeAll(Collection<?> c) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public void clear() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public E lower(E e) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public E floor(E e) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public E ceiling(E e) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public E higher(E e) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public E pollFirst() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public E pollLast() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Iterator<E> iterator() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public NavigableSet<E> descendingSet() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Iterator<E> descendingIterator() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public NavigableSet<E> headSet(E toElement, boolean inclusive) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public SortedSet<E> subSet(E fromElement, E toElement) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public SortedSet<E> headSet(E toElement) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public SortedSet<E> tailSet(E fromElement) {
		// TODO Auto-generated method stub
		return null;
	}

}
