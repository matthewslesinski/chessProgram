package moves;

import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import boardFeatures.Square;
import lines.Direction;
import lines.File;
import lines.Rank;
import moveCalculationStructures.KingMoveSet;
import pieces.Piece;
import pieces.PieceType;
import representation.Board;
import support.UtilityFunctions;

public class LazyPreProcessing<B extends Board> extends StraightforwardPreProcessing<B> {
	
	private final Map<Direction, Square> possiblePinners;
	
	public LazyPreProcessing(B board) {
		super(board);
		possiblePinners = getListOfSquaresForPiecesOfColor(toMove.getOtherColor(), PieceType.getLineMovers())
			.stream().filter(this::canAttackKing)
			.collect(Collectors.toMap(kingSquare::getDirectionToSquare, UtilityFunctions::identity, kingSquare::whichIsCloser, () -> new EnumMap<>(Direction.class)));
			
	}

	/**
	 * Inches in a direction from curr until either some piece is found or we've hit the end, after passing the required number of pieces
	 * @param curr The {@code Square} to start the search from
	 * @param direction The {@code Direction} to search in
	 * @param hitTheEnd This tells us if we have reached the end of where we need to search.
	 * @param numToPass The number of squares with pieces on them that must be passed. Any non-null square returned from this method will have
	 * this many pieces in between it and the start square {@code curr}
	 * @return The {@code Square} that we've found, or null
	 */
	private Square getNextSquareWithPieceUnderConstraints(Square curr, Direction direction, Predicate<Square> hitTheEnd, int numToPass) {
		int passed = 0;
		while (!hitTheEnd.test(curr = curr.getNeighbor(direction))) {
			if (!isEmptySquare(curr) && passed == numToPass) {
				return curr;
			}
			passed += 1;
		}
		return passed == numToPass ? curr : null;
	}
	
	/**
	 * Searches for the next {@code Square} with a piece, or null
	 * @param curr The {@code Square} to start searching from
	 * @param direction The {@code Direction} to search in
	 * @param hitTheEnd If we know we no longer need to search and can just end the search
	 * @return The {@code Square} with a piece on it, or null
	 */
	private Square getNextSquareWithPieceUnderConstraint(Square curr, Direction direction, Predicate<Square> hitTheEnd) {
		return getNextSquareWithPieceUnderConstraints(curr, direction, hitTheEnd, 0);
	}
	
	/**
	 * Checks each successive {@code Square} in the given {@code Direction} until a {@code Square} with a {@code Piece} is found or we fall off the board
	 * @param curr The {@code Square} to search from
	 * @param direction The {@code Direction} to search
	 * @return The next {@code Square} in that {@code Direction} with a {@code Piece}, or null if none
	 */
	private Square getNextSquareWithPiece(Square curr, Direction direction) {
		return getNextSquareWithPieceUnderConstraint(curr, direction, UtilityFunctions::isNull);
	}
	
	@Override
	protected void calculateSquareAttackers(Square potentiallyAttackedSquare, KingMoveSet kingMoves,
			Set<Square> coveredAttackers, Set<Square> squaresToIgnore) {
		boolean squareIsAttacked = false;
		Piece potentiallyAttackedOccupant = getPieceAtSquare(potentiallyAttackedSquare);
		if (isNotSameColor(potentiallyAttackedOccupant)) {
			for (Direction direction : Direction.getOutwardDirections()) {
				Square nextWithOccupant = getNextSquareWithPiece(potentiallyAttackedSquare, direction);
				Piece occupant = getPieceAtSquare(nextWithOccupant);
				if (!isNotAPiece(occupant) && occupant.getColor() != toMove && !coveredAttackers.contains(nextWithOccupant)) {
					boolean lineMover = occupant.getType().isLongRange();
					Map<Direction, Boolean> unblockedDirections = null;
					if (lineMover) {
						unblockedDirections = new EnumMap<>(Direction.class);
						unblockedDirections.put(nextWithOccupant.getDirectionToSquare(potentiallyAttackedSquare), true);
					}
					coveredAttackers.add(nextWithOccupant);
					for (Square attackedSquare : kingMoves.getAttackedSquares(nextWithOccupant, this::getPieceAtSquare)) {
						Direction toAttackedSquare = nextWithOccupant.getDirectionToSquare(attackedSquare);
						if (lineMover && !unblockedDirections.containsKey(toAttackedSquare)) {
							unblockedDirections.put(toAttackedSquare, !isMovementBlocked(nextWithOccupant, attackedSquare));
						}
						if (!lineMover || unblockedDirections.get(toAttackedSquare) == Boolean.TRUE) {
							if (attackedSquare == potentiallyAttackedSquare) {
								squareIsAttacked = true;
							}
							Set<Square> attackersOfSquare = attackedSquaresAroundKing.getOrDefault(attackedSquare, EnumSet.noneOf(Square.class));
							attackedSquaresAroundKing.putIfAbsent(attackedSquare, attackersOfSquare);
							attackersOfSquare.add(nextWithOccupant);
						}
					}
					if (squareIsAttacked) {
						return;
					}
				} else if (!isNotAPiece(occupant) && occupant.getColor() == toMove) {
					Direction fromKing = kingSquare.getDirectionToSquare(nextWithOccupant);
					if (fromKing == direction && possiblePinners.containsKey(fromKing) &&
							getNextSquareWithPiece(nextWithOccupant, fromKing) == possiblePinners.get(fromKing)) {
						pins.put(nextWithOccupant, fromKing);
					}
				}
			}
		}
	}
	
	@Override
	protected void calculateKingAttackers(Set<Square> coveredAttackers) {
		// Nothing needs to be done here that wasn't done in calculateSquareAttackers
		return;
	}

	@Override
	public boolean isMovementBlocked(Square start, Square end) {
		Direction dir = end.getDirectionToSquare(start);
		if (dir == Direction.NONE) {
			return false;
		}
		return getNextSquareWithPieceUnderConstraint(end, dir, ((Predicate<Square>) this::isEmptySquare).negate().or(Predicate.isEqual(start))) != start;
	}

	@Override
	public boolean isEnPassantPinned(File movingPawnFile) {
		File captureFile = getEnPassantFile();
		// If en passant isn't allowed, it can't be pinned
		if (captureFile == null) {
			return false;
		}
		Rank enPassantRank = toMove.getEnPassantCaptureRank();
		// The king must be on the same rank for this special pin
		if (kingSquare.getRank() != enPassantRank) {
			return false;
		}
		Square pawnSquare = Square.getByFileAndRank(captureFile, enPassantRank);
		// Get the possible rooks or queens that might pin the pawn, which means they're the closest one in the same direction from the king as the pawn
		Direction fromKing = kingSquare.getDirectionToSquare(pawnSquare);
		Optional<Square> attackingHorizontalMoverOptional = getListOfSquaresForPiecesOfColor(toMove, PieceType.getHorizontalMovers()).stream()
			.filter(square -> kingSquare.getDirectionToSquare(square) == fromKing).reduce(kingSquare::whichIsCloser);
		// If there's no possible pinning rook/queen, the en passant isn't pinned
		if (!attackingHorizontalMoverOptional.isPresent()) {
			return false;
		}
		Square pinningPiece = attackingHorizontalMoverOptional.get();
		// If the pinning piece is closer than the en passant pawn, en passant can't be pinned
		if (kingSquare.whichIsCloser(pinningPiece, pawnSquare) == pinningPiece) {
			return false;
		}
		Square curr = kingSquare;
		// This will get the next square, with 2 in between, from the king in the given direction, such that the returned
		// square has some piece on it, and is no further than the pinning piece's square.
		return getNextSquareWithPieceUnderConstraints(curr, fromKing, Predicate.isEqual(pinningPiece), 2) == pinningPiece;

	}
}
