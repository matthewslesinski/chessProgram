package moves;

import java.util.Arrays;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import boardFeatures.Square;
import lines.Direction;
import lines.File;
import moveCalculationStructures.KingMoveSet;
import pieces.Piece;
import pieces.PieceType;
import representation.Board;
import support.UtilityFunctions;

public class LazyPreProcessing<B extends Board> extends StraightforwardPreProcessing<B> {

	private final Map<Direction, Square> possiblePinners;
	
	public LazyPreProcessing(B board) {
		super(board);
		possiblePinners = Arrays.stream(PieceType.getLineMovers())
			.map(UtilityFunctions.bind(Piece::getByColorAndType, toMove.getOtherColor())).map(this::getListOfSquaresForPiece)
			.reduce(Collections.emptyList(), (list1, list2) -> UtilityFunctions.concat(list1, list2)).stream().filter(this::canAttackKing)
			.collect(Collectors.toMap(kingSquare::getDirectionToSquare, UtilityFunctions::identity, kingSquare::whichIsCloser, () -> new EnumMap<>(Direction.class)));
			
	}


	@Override
	protected void calculateKingAttackers(Set<Square> coveredAttackers) {
		// TODO Auto-generated method stub
		
	}

	private Square getNextSquareWithPiece(Square curr, Direction direction) {
		while ((curr = curr.getNeighbor(direction)) != null) {
			if (!isEmptySquare(curr)) {
				return curr;
			}
		}
		return null;
	}
	
	@Override
	protected void calculateSquareAttackers(Square potentiallyAttackedSquare, KingMoveSet kingMoves,
			Set<Square> coveredAttackers, Set<Square> squaresToIgnore) {
		boolean squareIsAttacked = false;
		Piece potentiallyAttackedOccupant = getPieceAtSquare(potentiallyAttackedSquare);
		if (isNotSameColor(potentiallyAttackedOccupant)) {
			for (Direction direction : Direction.getOutwardDirections()) {
				Square nextWithOccupant = getNextSquareWithPiece(potentiallyAttackedSquare, direction);
				Piece occupant = getPieceAtSquare(nextWithOccupant);
				if (!isNotAPiece(occupant) && occupant.getColor() != toMove && !coveredAttackers.contains(nextWithOccupant)) {
					boolean lineMover = occupant.getType().isLongRange();
					Map<Direction, Boolean> unblockedDirections = null;
					if (lineMover) {
						unblockedDirections = new EnumMap<>(Direction.class);
						unblockedDirections.put(nextWithOccupant.getDirectionToSquare(potentiallyAttackedSquare), true);
					}
					coveredAttackers.add(nextWithOccupant);
					for (Square attackedSquare : kingMoves.getAttackedSquares(nextWithOccupant, this::getPieceAtSquare)) {
						Direction toAttackedSquare = nextWithOccupant.getDirectionToSquare(attackedSquare);
						if (lineMover && !unblockedDirections.containsKey(toAttackedSquare)) {
							unblockedDirections.put(toAttackedSquare, !isMovementBlocked(attackedSquare, nextWithOccupant));
						}
						if (!lineMover || unblockedDirections.get(toAttackedSquare) == Boolean.TRUE) {
							if (attackedSquare == potentiallyAttackedSquare) {
								squareIsAttacked = true;
							}
							Set<Square> attackersOfSquare = attackedSquaresAroundKing.getOrDefault(attackedSquare, EnumSet.noneOf(Square.class));
							attackedSquaresAroundKing.putIfAbsent(attackedSquare, attackersOfSquare);
							attackersOfSquare.add(nextWithOccupant);
						}
					}
					if (squareIsAttacked) {
						return;
					}
				} else if (!isNotAPiece(occupant) && occupant.getColor() == toMove) {
					Direction fromKing = kingSquare.getDirectionToSquare(nextWithOccupant);
					if (fromKing == direction && possiblePinners.containsKey(fromKing) &&
							getNextSquareWithPiece(nextWithOccupant, fromKing) == possiblePinners.get(fromKing)) {
						pins.put(nextWithOccupant, fromKing);
					}
				}
			}
		}
	}

	@Override
	public boolean isMovementBlocked(Square start, Square end) {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean isEnPassantPinned(File movingPawnFile) {
		// TODO Auto-generated method stub
		return false;
	}
}
