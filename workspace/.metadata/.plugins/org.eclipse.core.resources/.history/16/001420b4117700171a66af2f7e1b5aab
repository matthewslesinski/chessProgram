package dataStructures;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import boardFeatures.SixteenthSector;
import boardFeatures.Square;
import support.BadArgumentException;

/**
 * This divides a board into 16 sectors (slices of a circle), based at some center square. It assumes that it will be given
 * one square per sector, that each square will not be in a sector adjacent to one also with a square, and that they are equidistant
 * from the center. This describes knight moves and king moves (without castling).
 * @author matthewslesinski
 *
 */
public class EvenlySpacedCircleImpl implements EvenlySpacedCircle {

	
	private Map<SixteenthSector, Square> relations = new EnumMap<SixteenthSector, Square>(SixteenthSector.class);
	private List<Square> addedSquares = new LinkedList<>();
	private Square center;
	
	public EvenlySpacedCircleImpl(Square center, Square... ring) {
		this(center, Arrays.asList(ring));
	}
	
	/**
	 * Build the circle with a center and a circumference
	 * @param center The center
	 * @param ring The squares in the surface
	 */
	public EvenlySpacedCircleImpl(Square center, Collection<Square> ring) {
		if (ring.size() > 8) {
			throw new BadArgumentException(ring, Collection.class, "Expected at most 8 squares");
		}
		for (Square squareToAdd : ring) {
			SixteenthSector sector = SixteenthSector.getRelation(center, squareToAdd);
			if (relations.containsKey(sector)) {
				throw new BadArgumentException(squareToAdd, Square.class, "The whole point of an EvenlySpacedCircle is to have one square in each sector");
			}
			relations.put(sector, squareToAdd);
			addedSquares.add(squareToAdd);
		}
		this.center = center;
	}

	@Override
	public Iterator<Square> iterator() {
		return addedSquares.iterator();
	}

	@Override
	public List<Square> getNearestSquares(Square remote) {
		SixteenthSector containingSector = SixteenthSector.getRelation(center, remote);
		if (relations.containsKey(containingSector)) {
			return Collections.singletonList(relations.get(containingSector));
		}
		return containingSector.getNearestSectors().stream()
				.map(sector -> relations.get(sector)).filter(square -> square != null)
				.collect(Collectors.toList());
	}

	@Override
	public int size() {
		return addedSquares.size();
	}

	@Override
	public boolean isEmpty() {
		return addedSquares.isEmpty();
	}

	@Override
	public boolean contains(Object o) {
		return addedSquares.contains(o);
	}

	@Override
	public Object[] toArray() {
		return addedSquares.toArray();
	}

	@Override
	public <T> T[] toArray(T[] a) {
		return addedSquares.toArray(a);
	}

	@Override
	public boolean add(Square e) {
		throw new BadArgumentException(this, this.getClass(), "Can't modify after creation");
	}

	@Override
	public boolean remove(Object o) {
		throw new BadArgumentException(this, this.getClass(), "Can't modify after creation");
	}

	@Override
	public boolean containsAll(Collection<?> c) {
		return addedSquares.containsAll(c);
	}

	@Override
	public boolean addAll(Collection<? extends Square> c) {
		throw new BadArgumentException(this, this.getClass(), "Can't modify after creation");
	}

	@Override
	public boolean removeAll(Collection<?> c) {
		throw new BadArgumentException(this, this.getClass(), "Can't modify after creation");
	}

	@Override
	public boolean retainAll(Collection<?> c) {
		throw new BadArgumentException(this, this.getClass(), "Can't modify after creation");
	}

	@Override
	public void clear() {
		throw new BadArgumentException(this, this.getClass(), "Can't modify after creation");		
	}
	
}
