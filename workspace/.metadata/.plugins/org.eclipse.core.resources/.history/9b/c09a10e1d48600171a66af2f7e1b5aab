package gamePlaying;

import java.io.IOException;

import moves.Move;
import representation.Board;
import support.Constants;
import support.MoveParser;

/**
 * A utility class used to define the methods used to perform the actions a player intends whenever they give some input. Ideally,
 * each public method in this class should be static, and of the form such that it takes an array of strings and a game and returns a string.
 * The returned string should be the response intended to send back to the players. The array of strings will contain the arguments supplied
 * to the action. Although a string array should always be passed to these actions, it should not necessarily always contain data. For instance, the
 * different input types that these actions are used for specify the range of number of arguments they expect, so these methods will never
 * be called with more or less arguments than expected. Some of the actions expect 0 arguments as their maximum. For instance, the {@code QUIT} input type
 * doesn't expect any arguments, so the corresponding method, {@code exit}, will only have an empty array passed to it. Furthermore, the arguments
 * are not guaranteed to be validated for a particular form. The game argument for each of these methods is the current game being played
 * and to perform the action within. 
 * @author matthewslesinski
 *
 */
public class UserActions {
	
	private static final String ILLEGAL_MOVE = "The attempted move is illegal. For a complete list of legal moves, type \":moves\".";
	
	/**
	 * Exits the game. This is the only way for a user to quit the program, other than by manually killing the process
	 * @param args The arguments to the action - none are expected
	 * @param game The game that is being played
	 * @return null, but it doesn't matter since we're exiting
	 */
	public static String exit(String[] args, Game game) {
		try {
			Constants.INPUT_READER.close();
		} catch(IOException e) {
			// TODO log this
		}
		System.exit(0);
		return null;
	}
	
	/**
	 * Undoes the last ply of the given game
	 * @param args The arguments to the action - none are expected
	 * @param game
	 * @return
	 */
	public static String redo(String[] args, Game game) {
		game.undoPlies(1);
		return null;
	}
	
	public static String undo(String[] args, Game game) {
		String argument = args[0];
		if (!argument.matches("\\d+")) {
			return "Can only undo an integer number of plies";
		}
		int numPlies = Integer.parseInt(argument);
		if (numPlies >= game.getPlyNumber()) {
			return "Can't undo more moves than were made";
		}
		game.undoPlies(numPlies);
		return null;
	}
	
	public static String exportPGN(String[] args, Game game) {
		// TODO
		return null;
	}
	
	public static String getFEN(String[] args, Game game) {
		// TODO
		return null;
	}
	
	public static String printMoves(String[] args, Game game) {
		if (args.length == 0) {
			return "Legal Moves: " + game.getCurrentPosition().getLegalMoves().toString();
		}
		// TODO
		return null;
	}
	
	public static String printBoard(String[] args, Game game) {
		return game.getCurrentPosition().toString();
	}
	
	public static String poke(String[] args, Game game) {
		// TODO
		return null;
	}
	
	public static String makeMove(String[] args, Game game) {
		String moveString = args[0];
		Board currentPosition = game.getCurrentPosition();
		Move nextMove = MoveParser.parseAlgebraicNotation(currentPosition, moveString);
		if (nextMove == null) {
			return ILLEGAL_MOVE;
		}
		Board nextPosition = currentPosition.performMove(nextMove);
		game.addPosition(nextPosition);
		if (nextPosition.isOver()) {
			return nextPosition.isInCheck() ? "Congratulations, " + game.getIdlePlayer().getName() + " has won" :
				"It's a draw!";
		}
		return null;
	}
	
}
