package moves;

import java.util.Arrays;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import boardFeatures.Square;
import lines.Direction;
import lines.File;
import lines.Rank;
import moveCalculationStructures.KingMoveSet;
import pieces.Piece;
import pieces.PieceType;
import representation.Board;
import support.UtilityFunctions;

public class LazyPreProcessing<B extends Board> extends StraightforwardPreProcessing<B> {

	private final Map<Direction, Square> possiblePinners;
	
	public LazyPreProcessing(B board) {
		super(board);
		possiblePinners = Arrays.stream(PieceType.getLineMovers())
			.map(UtilityFunctions.bind(Piece::getByColorAndType, toMove.getOtherColor())).map(this::getListOfSquaresForPiece)
			.reduce(Collections.emptyList(), UtilityFunctions::concat).stream().filter(this::canAttackKing)
			.collect(Collectors.toMap(kingSquare::getDirectionToSquare, UtilityFunctions::identity, kingSquare::whichIsCloser, () -> new EnumMap<>(Direction.class)));
			
	}


	@Override
	protected void calculateKingAttackers(Set<Square> coveredAttackers) {
		return;
	}

	private Square getNextSquareWithPiece(Square curr, Direction direction) {
		while ((curr = curr.getNeighbor(direction)) != null) {
			if (!isEmptySquare(curr)) {
				return curr;
			}
		}
		return null;
	}
	
	@Override
	protected void calculateSquareAttackers(Square potentiallyAttackedSquare, KingMoveSet kingMoves,
			Set<Square> coveredAttackers, Set<Square> squaresToIgnore) {
		boolean squareIsAttacked = false;
		Piece potentiallyAttackedOccupant = getPieceAtSquare(potentiallyAttackedSquare);
		if (isNotSameColor(potentiallyAttackedOccupant)) {
			for (Direction direction : Direction.getOutwardDirections()) {
				Square nextWithOccupant = getNextSquareWithPiece(potentiallyAttackedSquare, direction);
				Piece occupant = getPieceAtSquare(nextWithOccupant);
				if (!isNotAPiece(occupant) && occupant.getColor() != toMove && !coveredAttackers.contains(nextWithOccupant)) {
					boolean lineMover = occupant.getType().isLongRange();
					Map<Direction, Boolean> unblockedDirections = null;
					if (lineMover) {
						unblockedDirections = new EnumMap<>(Direction.class);
						unblockedDirections.put(nextWithOccupant.getDirectionToSquare(potentiallyAttackedSquare), true);
					}
					coveredAttackers.add(nextWithOccupant);
					for (Square attackedSquare : kingMoves.getAttackedSquares(nextWithOccupant, this::getPieceAtSquare)) {
						Direction toAttackedSquare = nextWithOccupant.getDirectionToSquare(attackedSquare);
						if (lineMover && !unblockedDirections.containsKey(toAttackedSquare)) {
							unblockedDirections.put(toAttackedSquare, !isMovementBlocked(nextWithOccupant, attackedSquare));
						}
						if (!lineMover || unblockedDirections.get(toAttackedSquare) == Boolean.TRUE) {
							if (attackedSquare == potentiallyAttackedSquare) {
								squareIsAttacked = true;
							}
							Set<Square> attackersOfSquare = attackedSquaresAroundKing.getOrDefault(attackedSquare, EnumSet.noneOf(Square.class));
							attackedSquaresAroundKing.putIfAbsent(attackedSquare, attackersOfSquare);
							attackersOfSquare.add(nextWithOccupant);
						}
					}
					if (squareIsAttacked) {
						return;
					}
				} else if (!isNotAPiece(occupant) && occupant.getColor() == toMove) {
					Direction fromKing = kingSquare.getDirectionToSquare(nextWithOccupant);
					if (fromKing == direction && possiblePinners.containsKey(fromKing) &&
							getNextSquareWithPiece(nextWithOccupant, fromKing) == possiblePinners.get(fromKing)) {
						pins.put(nextWithOccupant, fromKing);
					}
				}
			}
		}
	}

	@Override
	public boolean isMovementBlocked(Square start, Square end) {
		Direction dir = end.getDirectionToSquare(start);
		if (dir == Direction.NONE) {
			return false;
		}
		Square intermediate = end;
		while ((intermediate = intermediate.getNeighbor(dir)) != start) {
			if (!isEmptySquare(intermediate)) {
				return true;
			}
		}
		return false;
	}

	@Override
	public boolean isEnPassantPinned(File movingPawnFile) {
		File captureFile = getEnPassantFile();
		if (captureFile == null) {
			return false;
		}
		Rank enPassantRank = toMove.getEnPassantCaptureRank();
		if (kingSquare.getRank() != enPassantRank) {
			return false;
		}
		Square pawnSquare = Square.getByFileAndRank(captureFile, enPassantRank);
		Direction fromKing = kingSquare.getDirectionToSquare(pawnSquare);
		Optional<Square> attackingHorizontalMoverOptional = Arrays.stream(PieceType.getHorizontalMovers())
			.map(UtilityFunctions.bind(Piece::getByColorAndType, toMove).andThen(this::getListOfSquaresForPiece))
			.reduce(Collections.emptyList(), UtilityFunctions::concat).stream()
			.filter(square -> kingSquare.getDirectionToSquare(square) == fromKing)
			.reduce(kingSquare::whichIsCloser);
		if (!attackingHorizontalMoverOptional.isPresent()) {
			return false;
		}
		Square pinningPiece = attackingHorizontalMoverOptional.get();
		if (kingSquare.whichIsCloser(pinningPiece, pawnSquare) == pinningPiece) {
			return false;
		}
		int passed = 0;
		Square curr = kingSquare;
		while((curr = kingSquare.getNeighbor(fromKing)) != pinningPiece) {
			if (!isEmptySquare(curr)) {
				passed += 1;
			}
		}
		return passed == 2;
	}
}
