package immutableArrayBoard;

import java.util.Arrays;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import boardFeatures.Square;
import dataStructures.SquareSet;
import gamePlaying.Color;
import moves.ProcessedBoard;
import moves.SolidPreProcessing;
import pieces.Piece;
import pieces.PieceType;
import moves.BasicMove;
import moves.Move;
import moves.MoveSet;
import representation.MoveGenerator;
import support.BadArgumentException;
import support.UtilityFunctions;

/**
 * Calculates the moves for a given position. This is a mutable object, and 
 * @author matthewslesinski
 *
 */
public class ImmutableArrayMoveGenerator extends MoveGenerator<ImmutableArrayBoard> {
	
	
	private ProcessedBoard<ImmutableArrayBoard> preprocessing;
	private Set<Square> safeKingSquares;
	private Set<Square> checks;
	private List<Move> moves;
	private boolean isInCheck;
	private Color toMove;
	private Square kingSquare;
	
	
	
	@Override
	public Set<Move> calculateMoves(ImmutableArrayBoard board) {
		preprocessing = new SolidPreProcessing<>(board);
		preprocessing.calculateKingSafety();
		safeKingSquares = preprocessing.getSafeKingDestinations();
		checks = preprocessing.whoIsAttackingTheKing();
		isInCheck = !checks.isEmpty();
		toMove = preprocessing.whoseMove();
		kingSquare = preprocessing.getListOfSquaresForPiece(Piece.getByColorAndType(toMove, PieceType.KING)).get(0);
		realizeMoves();
		return new MoveSet(moves, BasicMove::new);
	}
	
	private void realizeMoves() {
		addSafeKingMoves();
		switch (checks.size()) {
		case 0:
			
			break;
		case 1:
			
			break;
		default:
			
		}
	}
	
	
	private Map<Square, SquareSet> getPossibleMovesForPieceTypes(PieceType... pieceTypes) {
		List<Square> pieceSquares = UtilityFunctions.concat(Arrays.stream(pieceTypes)
				.map(UtilityFunctions.bind(Piece::getByColorAndType, toMove)).map(preprocessing::getListOfSquaresForPiece)
				.collect(Collectors.toList()));
		return pieceSquares.stream().collect(Collectors.toMap(square -> square, 
				(Square square) -> square.getPossibleMovesByPiece(preprocessing.getPieceAtSquare(square)),
				(squareSet1, squareSet2) -> squareSet1, () -> new EnumMap<>(Square.class)));
	}
	
	private void addSafeKingMoves() {
		kingSquare.getPossibleThreatsByPiece(Piece.getByColorAndType(toMove, PieceType.KING)).stream()
		.filter(square -> safeKingSquares.contains(square)).forEach(endSquare -> addBasicMove(kingSquare, endSquare));
	}
	
	private void addCastling() {
		// TODO
	}
	
	private void addCheckBeaters(Square check) {
		getPossibleMovesForPieceTypes(PieceType.getExpendablePieces()).entrySet().stream().
	}
	
	
	
	
	private void addBasicMove(Square startSquare, Square endSquare) {
		moves.add(buildBasicMove(startSquare, endSquare));
	}
	
	private Move buildBasicMove(Square start, Square end) {
		
	}
	

}
