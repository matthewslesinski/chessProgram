package pieces;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import boardFeatures.Square;
import gamePlaying.Color;
import moves.Move;
import representation.Board;

/**
 * Provides the utility method(s) for calculating a knight's legal moves
 * @author matthewslesinski
 *
 */
public class Knight extends PieceUtility{
	
	Knight(PieceType piece) {
		super();
	}
	
	@Override
	public Set<Move> getLegalMoves(Square square, Board board, Color color) {
		// TODO Auto-generated method stub
		return null;
	}
	
	/** The offsets between a knight's current square and the squares it can move to */
	public static final List<List<Integer>> KNIGHT_MOVE_OFFSETS = Arrays.asList(
		Arrays.asList(2, 1),
		Arrays.asList(2, -1),
		Arrays.asList(1, -2),
		Arrays.asList(-1, -2),
		Arrays.asList(-2, -1),
		Arrays.asList(-2, 1),
		Arrays.asList(-1, 2),
		Arrays.asList(1, 2)
	);

	@Override
	protected PieceType determinePieceType() {
		return PieceType.KNIGHT;
	}

	@Override
	protected int determineMaxAttackDistance() {
		return 3;
	}

	private boolean canMove(Square square, Board board, Color color) {
		// TODO
		return true;
	}
	
	@Override
	protected List<Square> getSquaresToMoveTo(Square square, Board board, Color color) {
		return canMove(square, board, color) ? square.getKnightJumps().stream().filter(candidate -> colorIsNotAtSquare(candidate, board, color)).collect(Collectors.toList()) : Collections.emptyList();
	}
}
