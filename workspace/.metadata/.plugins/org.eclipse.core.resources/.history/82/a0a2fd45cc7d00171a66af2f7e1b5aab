package immutableArrayBoard;

import java.util.List;
import java.util.Set;

import boardFeatures.Square;
import gamePlaying.Color;
import moves.ProcessedBoard;
import moves.SolidPreProcessing;
import pieces.Piece;
import pieces.PieceType;
import moves.BasicMove;
import moves.Move;
import moves.MoveSet;
import representation.MoveGenerator;
import support.BadArgumentException;
import support.UtilityFunctions;

/**
 * Calculates the moves for a given position. This is a mutable object, and 
 * @author matthewslesinski
 *
 */
public class ImmutableArrayMoveGenerator extends MoveGenerator<ImmutableArrayBoard> {
	
	
	private ProcessedBoard<ImmutableArrayBoard> preprocessing;
	private Set<Square> safeKingSquares;
	private Set<Square> checks;
	private List<Move> moves;
	private boolean isInCheck;
	private Color toMove;
	private Square kingSquare;
	
	
	
	@Override
	public Set<Move> calculateMoves(ImmutableArrayBoard board) {
		preprocessing = new SolidPreProcessing<>(board);
		preprocessing.calculateKingSafety();
		safeKingSquares = preprocessing.getSafeKingDestinations();
		checks = preprocessing.whoIsAttackingTheKing();
		isInCheck = !checks.isEmpty();
		toMove = preprocessing.whoseMove();
		kingSquare = preprocessing.getListOfSquaresForPiece(Piece.getByColorAndType(toMove, PieceType.KING)).get(0);
		realizeMoves();
		return new MoveSet(moves, BasicMove::new);
	}
	
	private void realizeMoves() {
		calculateSafeKingMoves();
		switch (checks.size()) {
		case 0:
			
			break;
		case 1:
			
			break;
		default:
			
		}
	}
	
	private void calculateSafeKingMoves() {
		kingSquare.getPossibleThreatsByPiece(Piece.getByColorAndType(toMove, PieceType.KING)).stream()
		.filter(square -> safeKingSquares.contains(square)).map(UtilityFunctions.bind(this::buildBasicMove, kingSquare)).forEach(moves::add);
	}
	
	private Move buildBasicMove(Square start, Square end) {
		
	}
	

}
