package gamePlaying;

import java.util.HashMap;
import java.util.Map;
import java.util.function.BiFunction;
import java.util.function.Function;

import support.UtilityFunctions;

public enum InputType {

	MOVE(null, 1, 1),
	POKE(null, 0, 0, "poke"),
	PRINT_MOVES(null, 0, 0, "moves"),
	PRINT_BOARD(null, 0, 0, "board"),
	GET_FEN(null, 0, 0, "fen"),
	EXPORT_PGN(null, 0, 0, "export", "pgn"),
	UNDO(null, 1, 1, "undo"),
	REDO(null, 0, 0, "redo"),
	QUIT(Game::exit, 0, 0, "quit");
	
	private final String[] expectedInputs;
	private final BiFunction<String[], Game<?>, String> action;
	private final int minArgs;
	private final int maxArgs;
	
	
	private static final Map<String, InputType> INTERNAL_MAPPING = new HashMap<>();
	static {
		for (InputType type : values()) {
			for (String input : type.expectedInputs) {
				INTERNAL_MAPPING.put(input, type);
			}
		}
	}
	
	private InputType(BiFunction<String[], Game<?>, String> action, int minArgs, int maxArgs, String... expectedInputs) {
		this.expectedInputs = expectedInputs;
		this.action = action;
		this.minArgs = minArgs;
		this.maxArgs = maxArgs;
	}
	
	public static InputType getInputType(String input) {
		input = input.trim();
		if (input.startsWith(":")) {
			return INTERNAL_MAPPING.get(input.split("\\s+")[0].substring(1).toLowerCase());
		}
		return MOVE;
	}
	
	public Function<Game<?>, String> getAction(String input) {
		String[] args = getArgsFromInput(input);
		if (args.length < minArgs) {
			return (game -> String.format("More arguments were expected for this action type. At least %d arguments must be provided", minArgs));
		}
		if (args.length > maxArgs) {
			return (game -> String.format("Less arguments were expected for this action type. At most %d arguments must be provided", maxArgs));
		}
		return UtilityFunctions.bind(action, args);
	}
	
	private String[] getArgsFromInput(String input) {
		return input.split("(^\\s*:\\w*)?\\s+");
	}
	
	
}
