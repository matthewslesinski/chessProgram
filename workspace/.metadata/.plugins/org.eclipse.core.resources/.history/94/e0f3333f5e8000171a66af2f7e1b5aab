package immutableArrayBoard;


import java.util.function.Supplier;

import boardFeatures.File;
import boardFeatures.Square;
import gamePlaying.Color;
import moves.Move;
import pieces.Piece;
import representation.Board;
import representation.BoardBuilder;
import representation.CastlingRights;
import representation.MoveGenerator;
import representation.MoveMaker;

/**
 * This is the most intuitive representation of a board. It holds a place for each square (at some index and some bit in the {@code board} array) and
 * the value at that square's place represents a piece. Furthermore, making a move to get to a new position will result in creating a new instance of
 * this class. Whether or not there's a more efficient implementation (such as bitboards), this one is the easiest to work with as a starting point.
 * @author matthewslesinski
 *
 */
public class ImmutableArrayBoard extends Board {

	private static final int FIRST_CASTLING_RIGHT_BIT = 0;
	
	private static final int RIGHTS_INDEX = 8;
	
	private static final int ARRAY_SIZE = 9;
	
	private static final int COLOR_MASK = 0x100;
	
	private static final int EN_PASSANT_INDEX = 4;
	
	private static final int EN_PASSANT_PERMISSION_MASK = 0b1000;
	
	private static final int NUMBER_OF_BITS_PER_PIECE = 4;
	
	private static final int ONES_IN_EN_PASSANT_BITS = 0b11110000;
	
	private static final int FOUR_ONES = 0b1111;
	
	/**
	 * The array containing the pieces and other board information, and so the actual internal representation of this {@code Board}.
	 * The first 8 indices contain ints representing the file with that index. Each of those ints is divided into 8 groups of four bits.
	 * A piece can be encoded in 4 bits. So that's what's stored in each group of 4 bits: the piece stored at that square when indexing into
	 * the file to get the rank. The last index of the array holds the extra information about board state, such as who's to move. This int
	 * says what castling is potentially allowed, using the first four bits, now or in a deeper position from this one. It also uses the second 4 bits
	 * to say what file a pawn could take a pawn from through en passant, and it uses the first bit of the next quarter of the int to say whose move it is.
	 */
	private final int[] board;
	
	private static final Supplier<MoveGenerator<ImmutableArrayBoard>> moveGeneratorConstructor = ImmutableArrayMoveGenerator::new;
		
	
	private ImmutableArrayBoard(int[] board) {
		this.board = board;
	}
	
	
	@Override
	public Piece getPieceAtSquare(Square square) {
		return Piece.getPieceByBits(getBitsAtSquare(square, board));
	}


	@Override
	public Color whoseMove() {
		return Color.getColor((board[RIGHTS_INDEX] & COLOR_MASK) != 0);
	}
	
	@Override
	public boolean canCastle(CastlingRights right) {
		return board[RIGHTS_INDEX] >>> (FIRST_CASTLING_RIGHT_BIT + right.ordinal()) % 2 == 1;
	}

	@Override
	public File enPassantCaptureFile() {
		int relevantInfo = board[RIGHTS_INDEX] >>> EN_PASSANT_INDEX;
		return File.getByIndex((relevantInfo & EN_PASSANT_PERMISSION_MASK) != 0 ?
				relevantInfo & 0b111 : null);
	}

	
	@Override
	public Board performMove(Move move) {
		MoveMaker<ImmutableArrayBoard> maker = new ImmutableArrayBoardMoveMaker();
		return maker.performMove(move, this);
	}


	@Override
	public void calculateMoves() {
		legalMoves = moveGeneratorConstructor.get().calculateMoves(this);
	}
	
	public static class Builder extends BoardBuilder<ImmutableArrayBoard> {
		
		private int[] board = new int[ARRAY_SIZE];
		
		private Builder() {}
		
		/**
		 * Initializes the board based on another board
		 * @param boardContainer The {@code ImmutableArrayBoard} to base this one off of
		 * @return This builder
		 */
		public static Builder fromBoard(int[] board) {
			Builder builder = new Builder();
			builder.board = board.clone();
			return builder;
		}
		
		/**
		 * Initializes the board based on another board
		 * @param boardContainer The {@code ImmutableArrayBoard} to base this one off of
		 * @return This builder
		 */
		public static Builder fromBoard(ImmutableArrayBoard boardContainer) {
			return fromBoard(boardContainer.board);
		}
		
		/**
		 * Initializes the board based on an array of pieces. This does not set any rights except whose move.
		 * @param pieces The array of pieces to put on the board
		 * @param whoToMove Whose current move it is
		 * @return This builder
		 */
		public static Builder fromBoard(Piece[] pieces, Color whoToMove) {
			Builder builder = new Builder();
			BoardBuilder.fromBoard(pieces, whoToMove, builder);
			return builder;
		}
		
		/**
		 * Produces an {@code ImmutableBoardBuilder} from a FEN string.
		 * @param fen: a FEN string representing the board.
		 * @return This builder
		 */
		public static Builder fromFen(String fen) {
			Builder builder = new Builder();
			BoardBuilder.fromFen(fen, builder);
			return builder;
		}
		
		@Override
		public Builder withColorToMove(Color color) {
			setRightsByBitMask(COLOR_MASK, color.isWhite());
			return this;
		}
		
		@Override
		public Builder withPieceAtSquare(Piece piece, Square square) {
			setPieceAtSquare(piece.getBitRepresentation(), square);
			return this;
		}
		
		@Override
		public Builder withCastlingRight(CastlingRights castlingRight, boolean enabled) {
			setRightsByBitMask(0x1 << (castlingRight.ordinal() + FIRST_CASTLING_RIGHT_BIT), enabled);
			return this;
		}
		
		@Override
		public Builder withEnPassant(File file) {
			setRightsByBitMask(file != null ?
					(file.getIndex() | EN_PASSANT_PERMISSION_MASK) << EN_PASSANT_INDEX : ONES_IN_EN_PASSANT_BITS,
					file != null);
			return this;
		}
		
		@Override
		public ImmutableArrayBoard build() {
			return new ImmutableArrayBoard(board);
		}
		
		/**
		 * Sets the rights for the board to have a certain mask
		 * The way this works is by: if {@code orBoolean} is true, we want to set all the bits that are 1 in mask
		 * to 1 in the board, without touching the others, and if {@code orBoolean} is false, we want to set all the
		 * bits that are 0 in mask to 0 in the board, without touching the others. Therefore, if it's true, we just OR
		 * with the mask, but if it's false, we do the opposite, which is AND with the complement of the mask. In other
		 * words, the mask should have every bit be 0 except for the ones that we want to set, and we will set those bits
		 * to 1 if {@code orBoolean} is true, and to 0 if false.
		 * @param mask The mask
		 * @param orBoolean Whether the mask should be ORed, or the reverse of the mask should be ANDed
		 */
		private void setRightsByBitMask(int mask, boolean orBoolean) {
			board[RIGHTS_INDEX] = orBoolean ? board[RIGHTS_INDEX] | mask : (board[RIGHTS_INDEX] & ~mask);
		}
		
		/**
		 * Sets a bit representation of a piece at the bit placement for the given square
		 * @param pieceBits The bit representation of the piece
		 * @param square The square the piece is on
		 */
		private void setPieceAtSquare(int pieceBits, Square square) {
			int fileIndex = square.getFile().getIndex();
			board[fileIndex] = board[fileIndex] | (pieceBits << (square.getRank().getIndex() * NUMBER_OF_BITS_PER_PIECE));
		}
	}
	
	/**
	 * Gets the bit representation of the piece at a square
	 * @param square The square to check
	 * @param board The board containing the piece
	 * @return The bit representation, where 0 is nothing, 1-6 is a white piece, and 7-12 is a black piece
	 */
	private int getBitsAtSquare(Square square, int[] board) {
		return (board[square.getFile().getIndex()] >>> (square.getRank().getIndex() * NUMBER_OF_BITS_PER_PIECE)) & FOUR_ONES;
	}

	
}
